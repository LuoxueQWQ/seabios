此页面提供了一些主要代码的高级描述
SeaBIOS 过渡的阶段和一般信息
整体代码流程。

SeaBIOS 代码阶段
===================

SeaBIOS 代码在其运行过程中经历了几个不同的代码阶段
执行生命周期。 了解这些代码阶段可以在以下情况下有所帮助：
阅读和增强代码。

后阶段
----------

开机自检 (POST) 阶段是系统的初始化阶段
BIOS。 当 SeaBIOS 首次开始执行时进入此阶段。 这
该阶段的目标是初始化内部状态，初始化外部状态
接口，检测并设置硬件，然后开始启动
阶段。

在模拟器上，当 CPU 开始以 16 位执行时，此阶段开始
模式位于 0xFFFF0000:FFF0。 模拟器将 SeaBIOS 二进制文件映射到此
地址，SeaBIOS 将 romlayout.S:reset_vector() 安排为
存在于那里。 此代码调用 romlayout.S:entry_post() ，然后
在 32 位模式下调用 post.c:handle_post()。

在 coreboot 上，构建将 romlayout.S:entry_elf() 安排为
以 32 位模式调用。 然后调用 post.c:handle_post()。

在 CSM 上，构建安排调用 romlayout.S:entry_csm()
（在 16 位模式下）。 然后以 32 位模式调用 csm.c:handle_csm()。
与模拟器和 coreboot 不同，SeaBIOS CSM POST 阶段是
使用 UEFI 协调，并且有多个来回调用
在整个 POST 过程中通过 handle_csm() 在 SeaBIOS 和 UEFI 之间进行连接
过程。

POST 阶段本身有几个子阶段。

* “preinit”子阶段：在[代码重定位]（链接概述#代码重定位）之前运行代码。
* “init”子阶段：初始化内部变量和
   接口。
*“设置”子阶段：设置硬件和驱动程序的代码。
*“prepboot”子阶段：完成接口并准备的代码
   对于启动阶段。

POST 阶段完成后，SeaBIOS 调用“int 0x19”
16 位模式下的软件中断开始启动阶段。

启动阶段
----------

启动阶段的目标是加载程序的第一部分
操作系统的引导加载程序进入内存并开始执行
引导加载程序。 当软件中断（“int 0x19”
或“int 0x18”）被调用。 代码流程以 16 位模式开始
romlayout.S:entry_19() 或 romlayout.S:entry_18() 然后
转换到 32 位模式并调用 boot.c:handle_19() 或
boot.c:handle_18()。

从技术上讲，引导阶段也是“运行时”阶段的一部分
SeaBIOS。 它通常在 POST 阶段之后立即调用，
但它也可以由操作系统调用或被调用
多次尝试找到有效的启动介质。 虽然
启动阶段 C 代码在 32 位模式下运行，它没有写入权限
0x0f0000-0x100000内存区域，无法调用各种
malloc_X() 调用。 参见[内存模型]（内存模型）
更多信息。

主要运行时阶段
------------------

主运行时阶段发生在引导阶段启动之后
操作系统。 一旦进入此阶段，就可以调用 SeaBIOS 代码
由操作系统使用各种 16 位和 32 位调用。 目标
此阶段的重点是支持这些遗留调用接口并
提供与 BIOS 标准的兼容性。 有多个入口
BIOS 要点 - 请参阅中的entry_XXX() 汇编器函数
romlayout.S.

调用者通过设置一个来使用大多数遗留入口点
特定的CPU寄存器状态，调用BIOS，然后检查
返回的CPU寄存器状态。 为了处理这个问题，SeaBIOS 将备份
当前寄存器状态转换为“struct bregs”（参见 romlayout.S，
Entryfuncs.S 和 bregs.h) 在调用入口处，然后将此结构传递给
C 代码。 然后，C 代码可以检查寄存器状态并修改
它。 然后汇编器入口函数将恢复（可能
修改）从“struct bregs”返回到的寄存器状态
呼叫者。

恢复并重新启动
-----------------

如上所述，在模拟器上 SeaBIOS 处理 0xFFFF0000:FFF0
机器启动执行向量。 这个向量也被称为
机器故障和某些机器“恢复”事件。 也可以是
由软件调用（如 0xF0000:FFF0）作为重新启动的请求
机器（在模拟器、coreboot 和 CSM 上）。

SeaBIOS“恢复和重新启动”代码处理这些调用和尝试
以确定调用者所需的操作。 代码流程开始于
romlayout.S:reset_vector() 中的 16 位模式调用
romlayout.S:entry_post() 调用 romlayout.S:entry_resume() ，其中
调用resume.c:handle_resume()。 根据要求
handle_resume() 代码可能会转换为 32 位模式。

从技术上讲，这段代码是“运行时”阶段的一部分，所以即使
它的一部分在 32 位模式下运行，但仍然具有与
运行时阶段。

线程数
=======

SeaBIOS内部实现了简单的协作多任务
系统。 该系统的工作原理是为每个“线程”提供自己的堆栈，并且
每当线程发出问题时，系统就会在这些堆栈之间循环
一次yield()调用。 这个“线程”系统可能更合适
描述为[协程](http://en.wikipedia.org/wiki/Coroutine)。
这些“线程”不会在多个CPU上运行并且不会被抢占，因此
不需要原子内存访问和复杂的锁定。

这些线程的目标是将总体启动时间减少
并行化硬件延迟。 （例如，通过允许等待
一个 ATA 硬盘驱动器旋转并响应命令
与等待 PS/2 键盘响应设置并行
命令。）这些硬件设置线程仅在
[POST 阶段](#POST_phase) 的“设置”子阶段。

实现线程的代码在stacks.c中。

硬件中断
===================

SeaBIOS C 代码始终在禁用硬件中断的情况下运行。 全部
C 代码入口点（参见 romlayout.S）要小心地显式地
禁用硬件中断（通过“cli”）。 因为跑步与
禁用中断会增加中断延迟，任何可能的 C 代码
循环相当长的时间（超过约 1 毫秒）应该
定期调用yield()。 Yield() 调用将短暂启用
发生硬件中断，然后禁用中断，然后恢复
C代码的执行。

SeaBIOS 总是运行 C 代码有两个主要原因
中断被禁用。 第一个原因是外部软件可能
覆盖在硬件上调用的默认 SeaBIOS 处理程序
中断事件。 事实上，基于 DOS 的应用程序这样做很常见
这。 这些传统的第三方中断处理程序可能有
未记录的期望（例如堆栈位置和堆栈大小）和
可能会尝试回调各种 SeaBIOS 软件服务。
可以通过以下方式实现更高的兼容性和更可重复的结果
只允许在特定点发生硬件中断（通过yield()
来电）。 第二个原因是 SeaBIOS 的大部分运行在 32 位模式下。
尝试在 16 位模式和 32 位模式下处理中断
不需要在模式之间切换来委托这些中断
复杂。 虽然禁用中断可以增加中断
延迟，这只会影响遗留系统，其中的小幅增加
中断延迟不太可能被注意到。

额外的16位堆栈
=================

SeaBIOS 为两种硬件实现 16 位实模式处理程序
中断和软件请求“中断”。 在传统的 BIOS 中，
这些请求将使用调用者的堆栈空间。 但是，那
调用者必须提供的最小空间尚未确定
标准化和非常古老的 DOS 程序已被观察到分配
非常少量的堆栈空间（100 字节或更少）。

默认情况下，SeaBIOS 现在在大多数 16 位实机上切换到自己的堆栈
模式入口点。 这个额外的堆栈空间分配在[“low
内存”]（内存模型）。它确保 SeaBIOS 使用最少量的内存
这些遗留的调用者堆栈（通常不超过 16 个字节）
来电。 （最近定义的 BIOS 接口，例如
支持16位保护和32位保护模式调用标准化
具有足够空间的最小堆栈大小，而 SeaBIOS 一般不会
在这些情况下使用其额外的堆栈。）

实现此堆栈“跳跃”的代码位于 romlayout.S 和
stacks.c。
