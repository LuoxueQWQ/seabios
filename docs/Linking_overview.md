可能更合适
描述为[协程](http://en.wikipedia.org/wiki/Coroutine)。
这些“线程”不会在多个CPU上运行并且不会被抢占，因此
不需要原子内存访问和复杂的锁定。

这些线程的目标是将总体启动时间减少
并行化硬件延迟。 （例如，通过允许等待
一个 ATA 硬盘驱动器旋转并响应命令
与等待 PS/2 键盘响应设置并行
命令。）这些硬件设置线程仅在
[POST 阶段](#POST_phase) 的“设置”子阶段。

实现线程的代码在stacks.c中。

硬件中断
===================

SeaBIOS C 代码始终在禁用硬件中断的情况下运行。 全部
C 代码入口点（参见 romlayout.S）要小心地显式地
禁用硬件中断（通过“cli”）。 因为跑步与
禁用中断会增加中断延迟，任何可能的 C 代码
循环相当长的时间（超过约 1 毫秒）应该
定期调用yield()。 Yield() 调用将短暂启用
发生硬件中断，然后禁用中断，然后恢复
C代码的执行。

SeaBIOS 总是运行 C 代码有两个主要原因
中断被禁用。 第一个原因是外部软件可能
覆盖在硬件上调用的默认 SeaBIOS 处理程序
中断事件。 事实上，基于 DOS 的应用程序这样做很常见
这。 这些传统的第三方中断处理程序可能有
未记录的期望（例如堆栈位置和堆栈大小）和
可能会尝试回调各种 SeaBIOS 软件服务。
可以通过以下方式实现更高的兼容性和更可重复的结果
只允许在特定点发生硬件中断（通过yield()
来电）。 第二个原因是 SeaBIOS 的大部分运行在 32 位模式下。
尝试在 16 位模式和 32 位模式下处理中断
不需要在模式之间切换来委托这些中断
复杂。 虽然禁用中断可以增加中断
延迟，这只会影响遗留系统，其中的小幅增加
中断延迟不太可能被注意到。

额外的16位堆栈
=================

SeaBIOS 为两种硬件实现 16 位实模式处理程序
中断和软件请求“中断”。 在传统的 BIOS 中，
这些请求将使用调用者的堆栈空间。 但是，那
调用者必须提供的最小空间尚未确定
标准化和非常古老的 DOS 程序已被观察到分配
非常少量的堆栈空间（100 字节或更少）。

默认情况下，SeaBIOS 现在在大多数 16 位实机上切换到自己的堆栈
模式入口点。 这个额外的堆栈空间分配在[“low
内存”]（内存模型）。它确保 SeaBIOS 使用最少量的内存
这些遗留的调用者堆栈（通常不超过 16 个字节）
来电。 （最近定义的 BIOS 接口，例如
支持16位保护和32位保护模式调用标准化
具有足够空间的最小堆栈大小，而 SeaBIOS 一般不会
在这些情况下使用其额外的堆栈。）

实现此堆栈“跳跃”的代码位于 romlayout.S 和
stacks.c。
